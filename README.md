# Timer-Demo

## 目的
定时器的目的即为了在某个时间点，程序自身主动触发某个事件，而不需要外力去开启或者启动，以节省人力并统一管理

## 定时器实现方式
| 实现方式 | 插入 | 删除 | 查找最小值 | 优点 | 缺点
| ---- | ---- | ---- | ---- | ---- | ---- |
| 排序链表 | O(n) | O(1) | O(1)
| 最小堆  | O(log n) | O(log n) | O(1)
| 红黑树  | O(log n) | O(log n) | O(1) / O(log n)
| 跳表  | O(log n) ~ O(n) | O(log n) ~ O(n) | O(log n) ~ O(n)
| 时间轮  | O(1) | O(1) | O(1) ~ O(n) | 保证每次执行定时器任务都是 O(1) 复杂度，在定时器任务密集的情况下，性能优势非常明显 | 内存占用较大，当定时器使用不频繁，处理时间跨度很大的时候，效率低下

# 比较
最小堆 与 红黑树 比较，它比红黑树更适合做定时器，因为定时器是要经常找最小值（快要开始执行时间最小的，也就是马上要执行的任务），红黑树查找 key 的最小值节点的时间复杂度是O(h)，最小堆的最小值是它的根节点，它的复杂度为O(1)。

红黑树由于它平衡的是黑节点的高度，要是删除或者插入的节点位置是红色节点，就会增加时间复杂度，因此这个平衡是不稳定的，时间复杂度不是稳定的O(log2n)。最小堆采用的是完全二叉树，它是一种强平衡的书，如果树的高度为h，那么h-1层都是满二叉树，因此最小堆的时间复杂度是稳定的稳定的O(log2n)。所以最小堆在定时器方面是优于红黑树的。

## 最小堆
1. 最小堆任意节点都满足，其左右子女的元素均小于等于父节点的元素
2. 堆的空间结构是二叉树，物理存储是数组
3. 下标的计算
   1. 下标为 i 的节点的父节点下标：(i - 1) / 2 【向下取整】
   2. 下标为 i 的节点的左孩子下标：i * 2 + 1
   3. 下标为 i 的节点的右孩子下标：i * 2 + 2

